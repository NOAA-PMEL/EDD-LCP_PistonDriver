/* --COPYRIGHT--,BSD
 * Copyright (c) 2013, Texas Instruments Incorporated
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * *  Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * *  Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * *  Neither the name of Texas Instruments Incorporated nor the names of
 *    its contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * --/COPYRIGHT--*/


// Generated by FlowMeter Design Center: Fri Feb 26 16:05:04 PST 2021


/*******************************************************************************
* IMPORTANT: This is an autogenerated file. DO NOT MODIFY!
*******************************************************************************/


#include "bsp_esi_cal.h"

// Global variables

int16_t gAFE1Base0;
uint16_t gMaxDACCH0, gMinDACCH0;
uint16_t gThresholdH0, gThresholdL0;
int16_t gAFE1Base1;
uint16_t gMaxDACCH1, gMinDACCH1;
uint16_t gThresholdH1, gThresholdL1;


uint16_t gNoiseLevel = 0;
uint8_t  gESIStatusFlag = 0;
uint8_t  gStateSeparation = 0;




extern ESI_AFE2_InitParams gAFE2Settings;
extern ESI_TSM_InitParams gTSMSettings;



// Function Prototype
static void FindDAC(findDACParams *params);
static void FindDAC_Fast_Range(fastParams *params);
static void FindDAC_Fast_Successive(fastParams *params);





void TSM_Auto_cal(void)
{
	// constant and variable for TSM calibration
#define CYCLE_WIDTH 8      		// which is equal to (ESICLK / freq of LC) - 2
#define LC_THRESHOLD_TSM_CAL 1600
#define CH0_FINISH  BIT0
#define CH1_FINISH  BIT1
#define CH2_FINISH  BIT2

	int8_t calStatus = 0;
	int16_t mathTemp;
	uint16_t i;
	findDACParams fparams= {0};

	int8_t ch0Counter;
	int16_t dAC0_sum1, dAC0_sum2;	int8_t ch1Counter;
	int16_t dAC1_sum1, dAC1_sum2;



/**
 *
 * This module is used to find the signal level of LC oscillation for
 * ESICH0, ESICH1, ESICH2 or ESICH3 depending on user selection.
 * This calibration updates calibration delay:
 *
 *     -TSM state 3  -  7  for CH0
 *     -TSM state 13 - 17  for CH1
 *     -TSM state 23 - 27  for CH2
 *
 */


	dAC0_sum1 = dAC0_sum2 = 0;
	fparams.channel0Enabled = true;
	ch0Counter = 0 ;
	dAC1_sum1 = dAC1_sum2 = 0;
	fparams.channel1Enabled = true;
	ch1Counter = 0 ;




/*
 *
 * START of TSM Auto-calibration
 *
 */

	do{
		// Find DAC threshold using 12-BIT successive approximation
		FindDAC(&fparams);


		dAC0_sum2 = ESI_getAFE1DACValue(CHANNEL_0_DAC1_UPPER_REGISTER);
		dAC1_sum2 = ESI_getAFE1DACValue(CHANNEL_1_DAC1_UPPER_REGISTER);




		// Channel 0 TSM Auto-calibration
		if(!(calStatus&CH0_FINISH)){

			if (dAC0_sum2 > LC_THRESHOLD_TSM_CAL){
				if (dAC0_sum2 > dAC0_sum1){
					mathTemp = dAC0_sum2 - dAC0_sum1;
				}else{
					mathTemp = dAC0_sum1 - dAC0_sum2;
				}

				ch0Counter += 1;

				if (mathTemp > 12){
					if (ch0Counter > CYCLE_WIDTH){
						for (i= 0; i< ch0Counter / 2 ; i++){
							ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_3,
									ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_3) - 1);
						}      
						calStatus |= CH0_FINISH;
					}else{
						 ch0Counter = 0;
						 dAC0_sum1 = dAC0_sum2;
					}
				}else{
					dAC0_sum1 = dAC0_sum2;
				}
			}

			if(!(calStatus&CH0_FINISH)){

				// Determine which high frequency state can increment state
				// duration by 1
				if(!(ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_3) == ESI_TSM_STATE_DURATION_MAX)){
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_3,
							ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_3) + 1);
				}else if(!(ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_4) == ESI_TSM_STATE_DURATION_MAX)){
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_4,
							ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_4) + 1);
				}else if(!(ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_5) == ESI_TSM_STATE_DURATION_MAX)){
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_5,
							ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_5) + 1);
				}else if(!(ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_6) == ESI_TSM_STATE_DURATION_MAX)){
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_6,
							ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_6) + 1);
				}else if(!(ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_7) == ESI_TSM_STATE_DURATION_MAX)){
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_7,
							ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_7) + 1);
				}else{
					// If all high frequency state have been maxed out,
					// increment ACLK cycle by one and reset repeat cycles for
					// all high frequency time states
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_2,
												ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_2) + 1);
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_3, ESI_TSM_STATE_DURATION_MIN);
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_4, ESI_TSM_STATE_DURATION_MIN);
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_5, ESI_TSM_STATE_DURATION_MIN);
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_6, ESI_TSM_STATE_DURATION_MIN);
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_7, ESI_TSM_STATE_DURATION_MIN);
					dAC0_sum1 = dAC0_sum2 = 0;
					ch0Counter = 0;
				}
			}
		}		// Channel 1 TSM Auto-calibration
		if(!(calStatus&CH1_FINISH)){

			if (dAC1_sum2 > LC_THRESHOLD_TSM_CAL){
				if (dAC1_sum2 > dAC1_sum1){
					mathTemp = dAC1_sum2 - dAC1_sum1;
				}else{
					mathTemp = dAC1_sum1 - dAC1_sum2;
				}

				ch1Counter += 1;

				if (mathTemp > 12){
					if (ch1Counter > CYCLE_WIDTH){
						for (i= 0; i< ch1Counter / 2 ; i++){
							ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_13,
									ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_13) - 1);
						}      
						calStatus |= CH1_FINISH;
					}else{
						 ch1Counter = 0;
						 dAC1_sum1 = dAC1_sum2;
					}
				}else{
					dAC1_sum1 = dAC1_sum2;
				}
			}

			if(!(calStatus&CH1_FINISH)){

				// Determine which high frequency state can increment state
				// duration by 1
				if(!(ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_13) == ESI_TSM_STATE_DURATION_MAX)){
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_13,
							ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_13) + 1);
				}else if(!(ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_14) == ESI_TSM_STATE_DURATION_MAX)){
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_14,
							ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_14) + 1);
				}else if(!(ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_15) == ESI_TSM_STATE_DURATION_MAX)){
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_15,
							ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_15) + 1);
				}else if(!(ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_16) == ESI_TSM_STATE_DURATION_MAX)){
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_16,
							ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_16) + 1);
				}else if(!(ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_17) == ESI_TSM_STATE_DURATION_MAX)){
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_17,
							ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_17) + 1);
				}else{
					// If all high frequency state have been maxed out,
					// increment ACLK cycle by one and reset repeat cycles for
					// all high frequency time states
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_12,
												ESI_TSM_getTSMStateDuration(ESI_TSM_STATE_REG_12) + 1);
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_13, ESI_TSM_STATE_DURATION_MIN);
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_14, ESI_TSM_STATE_DURATION_MIN);
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_15, ESI_TSM_STATE_DURATION_MIN);
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_16, ESI_TSM_STATE_DURATION_MIN);
					ESI_TSM_setTSMStateDuration(ESI_TSM_STATE_REG_17, ESI_TSM_STATE_DURATION_MIN);
					dAC1_sum1 = dAC1_sum2 = 0;
					ch1Counter = 0;
				}
			}
		}




	}while(!(calStatus==(CH0_FINISH + CH1_FINISH)));

/*
 *
 * TSM Auto-calibration complete
 *
 */

}

void Find_Noise_level(void)
{
#define SEARCH_RANGE  							8
#define NOISE_LEVEL_DETECTION_TIME 				256

	uint16_t loopCounter = 0;
	fastParams fParams = {0};

    // set initial value for DAC max and min
	// this variable will record the DAC value of metal and non metal part of a rotor

	gMinDACCH0 = 0x0FFF;
	gMaxDACCH0 = 0x0000;
	fParams.channel0Enabled = true;
	gMinDACCH1 = 0x0FFF;
	gMaxDACCH1 = 0x0000;
	fParams.channel1Enabled = true;


	fParams.range = SEARCH_RANGE;

/**
 *
 *	Start of Noise-Level Detection
 *
 */

	// Loop for detection of noise level, taking 0.5 second;


	do {


		fParams.channel0StartingPoint = ESI_getAFE1DACValue(CHANNEL_0_DAC1_UPPER_REGISTER);
		fParams.channel1StartingPoint = ESI_getAFE1DACValue(CHANNEL_1_DAC1_UPPER_REGISTER);



		FindDAC_Fast_Range(&fParams);


		if(fParams.channel0Enabled == true){
			if (ESI_getAFE1DACValue(CHANNEL_0_DAC1_LOWER_REGISTER) < gMinDACCH0) {
				gMinDACCH0 = ESI_getAFE1DACValue(CHANNEL_0_DAC1_LOWER_REGISTER);
			}

			if (ESI_getAFE1DACValue(CHANNEL_0_DAC1_UPPER_REGISTER) > gMaxDACCH0) {
				gMaxDACCH0 = ESI_getAFE1DACValue(CHANNEL_0_DAC1_UPPER_REGISTER);
			}
		}		if(fParams.channel1Enabled == true){
			if (ESI_getAFE1DACValue(CHANNEL_1_DAC1_LOWER_REGISTER) < gMinDACCH1) {
				gMinDACCH1 = ESI_getAFE1DACValue(CHANNEL_1_DAC1_LOWER_REGISTER);
			}

			if (ESI_getAFE1DACValue(CHANNEL_1_DAC1_UPPER_REGISTER) > gMaxDACCH1) {
				gMaxDACCH1 = ESI_getAFE1DACValue(CHANNEL_1_DAC1_UPPER_REGISTER);
			}
		}


		loopCounter++;

	}while (loopCounter < NOISE_LEVEL_DETECTION_TIME); // run for approx 0.5 second

/**
 *
 *	End of Noise-Level Detection
 *
 */


	gThresholdH0 = gMaxDACCH0 - gMinDACCH0;
	gThresholdH1 = gMaxDACCH1 - gMinDACCH1;
	if (gThresholdH0 > gThresholdH1){
		gNoiseLevel = gThresholdH0;
	}else{
		gNoiseLevel = gThresholdH1;
	}

}

//******************************************************************************
//
// When the disc is rotating, the Max and Min of signal is found and their
// difference is required to be larger than gStateSeparation.
//
// After reaching the gStateSeparation, it will keep rotating for one more
// second to ensure a complete rotation is calibrated.
//
//******************************************************************************

void Set_DAC(void)
{
// min 4 ,  max 6;
#define SEPARATION_FACTOR   				4           

	uint16_t loopCounter = 0;
	fastParams fsParams= {0};


	gMinDACCH0 = 4096;
	gMaxDACCH0 = 0;
	gMinDACCH1 = 4096;
	gMaxDACCH1 = 0;



	fsParams.range = 5;

	fsParams.channel0Enabled = true;
	fsParams.channel1Enabled = true;



	// minimum times 4, maximum 6;
	gStateSeparation = gNoiseLevel*(SEPARATION_FACTOR-1)+gNoiseLevel/2;


	 // do loop for 1 more second after valid separation detected;
	do {
		// do loop for detection of valid Max-Min separation;
		do {

			fsParams.channel0StartingPoint = ESI_getAFE1DACValue(CHANNEL_0_DAC1_UPPER_REGISTER);
			fsParams.channel1StartingPoint = ESI_getAFE1DACValue(CHANNEL_1_DAC1_UPPER_REGISTER);



			FindDAC_Fast_Successive(&fsParams);


			if(fsParams.channel0Enabled ==true){
				if(ESI_getAFE1DACValue(CHANNEL_0_DAC1_LOWER_REGISTER) < gMinDACCH0){
					gMinDACCH0 = ESI_getAFE1DACValue(CHANNEL_0_DAC1_LOWER_REGISTER);
				}

				if(ESI_getAFE1DACValue(CHANNEL_0_DAC1_UPPER_REGISTER) > gMaxDACCH0){
					gMaxDACCH0 = ESI_getAFE1DACValue(CHANNEL_0_DAC1_UPPER_REGISTER);
				}
			}			if(fsParams.channel1Enabled ==true){
				if(ESI_getAFE1DACValue(CHANNEL_1_DAC1_LOWER_REGISTER) < gMinDACCH1){
					gMinDACCH1 = ESI_getAFE1DACValue(CHANNEL_1_DAC1_LOWER_REGISTER);
				}

				if(ESI_getAFE1DACValue(CHANNEL_1_DAC1_UPPER_REGISTER) > gMaxDACCH1){
					gMaxDACCH1 = ESI_getAFE1DACValue(CHANNEL_1_DAC1_UPPER_REGISTER);
				}
			}



			// To detect the a change due to rotation
			// if a separation of gStateSeparation is found, a rotation is
			// detected and keep running for 1 second to find the max and min

			gThresholdH0 = gMaxDACCH0 - gMinDACCH0;
			gThresholdH1 = gMaxDACCH1 - gMinDACCH1;



			// check for valid separation

			if(fsParams.channel0Enabled==true){
				if (gThresholdH0 > gStateSeparation){
					gESIStatusFlag |= VALID_SEPARATION_CH0;
				}
			}
			if(fsParams.channel1Enabled==true){
				if (gThresholdH1 > gStateSeparation){
					gESIStatusFlag |= VALID_SEPARATION_CH1;
				}
			}


		}while (!((gESIStatusFlag&VALID_SEPARATION_CH0)&&(gESIStatusFlag&VALID_SEPARATION_CH1)));



		loopCounter++;
	} while(loopCounter < 468)   ;   // 1 second for 2340Hz using Find_Fast_Successive();


	// "+" for INV version, "-" for non-INV version

	if(fsParams.channel0Enabled ==true){
		ESI_setAFE1DACValue((gMaxDACCH0 + gMinDACCH0)/2, CHANNEL_0_DAC1_UPPER_REGISTER);
		// "+" for INV version, "-" for non-INV version
		ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_0_DAC1_UPPER_REGISTER) + gNoiseLevel, CHANNEL_0_DAC1_LOWER_REGISTER);
		gAFE1Base0 = ESI_getAFE1DACValue(CHANNEL_0_DAC1_UPPER_REGISTER);
		// "-" for INV version, "+" for non-INV version
		ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_0_DAC1_UPPER_REGISTER) - gNoiseLevel, CHANNEL_0_DAC1_UPPER_REGISTER);
	}	if(fsParams.channel1Enabled ==true){
		ESI_setAFE1DACValue((gMaxDACCH1 + gMinDACCH1)/2, CHANNEL_1_DAC1_UPPER_REGISTER);
		// "+" for INV version, "-" for non-INV version
		ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_1_DAC1_UPPER_REGISTER) + gNoiseLevel, CHANNEL_1_DAC1_LOWER_REGISTER);
		gAFE1Base1 = ESI_getAFE1DACValue(CHANNEL_1_DAC1_UPPER_REGISTER);
		// "-" for INV version, "+" for non-INV version
		ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_1_DAC1_UPPER_REGISTER) - gNoiseLevel, CHANNEL_1_DAC1_UPPER_REGISTER);
	}


}




static void FindDAC(findDACParams *params)
{
	uint8_t i;
	// DAC Level tester, using Successive approximation approach
	uint16_t currentDACBit = 0x0800, prevDACBit = 0x0C00;

	// Set currentDACBit as initial value for all DAC register specified in
	// channelMask
	
	if(params->channel0Enabled==true){
		ESI_setAFE1DACValue(currentDACBit,CHANNEL_0_DAC1_UPPER_REGISTER);
		ESI_setAFE1DACValue(currentDACBit,CHANNEL_0_DAC1_LOWER_REGISTER);
	}

	if(params->channel1Enabled==true){
		ESI_setAFE1DACValue(currentDACBit,CHANNEL_1_DAC1_UPPER_REGISTER);
		ESI_setAFE1DACValue(currentDACBit,CHANNEL_1_DAC1_LOWER_REGISTER);
	}

	if(params->channel2Enabled==true){
		ESI_setAFE1DACValue(currentDACBit,CHANNEL_2_DAC1_UPPER_REGISTER);
		ESI_setAFE1DACValue(currentDACBit,CHANNEL_2_DAC1_LOWER_REGISTER);
	}


	// Clear any pending ESISTOP Interrupt and enable ESI module
	ESI_clearInterrupt(ESI_INTERRUPT_FLAG_ESISTOP);
	ESI_enableInterrupt(ESI_INTERRUPT_ESISTOP);
	ESI_enable();


	// Start DAC successive approximation routine for selected channels
	for(i = 0; i<12; i++)				 	// test 12 times as 12 bit DAC
	{

		// Wait for the ESISTOP flag
		//__bis_SR_register(LPM3_bits+GIE);

		// right shift one bit
		currentDACBit >>= 1;


		// Channel 0
		if(params->channel0Enabled==true){
			if (!ESI_getLatchedComparatorOutput(CHANNEL_0_PPU_SELECT)){
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_0_DAC1_UPPER_REGISTER) | currentDACBit,CHANNEL_0_DAC1_UPPER_REGISTER);
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_0_DAC1_LOWER_REGISTER) | currentDACBit,CHANNEL_0_DAC1_LOWER_REGISTER);
			}else{
				// reset the previous bit and set the next bit
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_0_DAC1_UPPER_REGISTER) ^ prevDACBit,CHANNEL_0_DAC1_UPPER_REGISTER);
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_0_DAC1_LOWER_REGISTER) ^ prevDACBit,CHANNEL_0_DAC1_LOWER_REGISTER);
			}
		}

		// Channel 1
		if(params->channel1Enabled==true){
			if (!ESI_getLatchedComparatorOutput(CHANNEL_1_PPU_SELECT)){
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_1_DAC1_UPPER_REGISTER) | currentDACBit,CHANNEL_1_DAC1_UPPER_REGISTER);
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_1_DAC1_LOWER_REGISTER) | currentDACBit,CHANNEL_1_DAC1_LOWER_REGISTER);
			}else{
				// reset the previous bit and set the next bit
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_1_DAC1_UPPER_REGISTER) ^ prevDACBit,CHANNEL_1_DAC1_UPPER_REGISTER);
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_1_DAC1_LOWER_REGISTER) ^ prevDACBit,CHANNEL_1_DAC1_LOWER_REGISTER);
			}
		}

		// Channel 2
		if(params->channel2Enabled==true){
			if (!ESI_getLatchedComparatorOutput(CHANNEL_2_PPU_SELECT)){
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_2_DAC1_UPPER_REGISTER) | currentDACBit,CHANNEL_2_DAC1_UPPER_REGISTER);
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_2_DAC1_LOWER_REGISTER) | currentDACBit,CHANNEL_2_DAC1_LOWER_REGISTER);
			}else{
				// reset the previous bit and set the next bit
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_2_DAC1_UPPER_REGISTER) ^ prevDACBit,CHANNEL_2_DAC1_UPPER_REGISTER);
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_2_DAC1_LOWER_REGISTER) ^ prevDACBit,CHANNEL_2_DAC1_LOWER_REGISTER);
			}
		}

		// right shift one bit
		prevDACBit >>= 1;


	}

	ESI_disable();
	ESI_disableInterrupt(ESI_INTERRUPT_ESISTOP);

}



static void FindDAC_Fast_Successive(fastParams *params)
{
	uint16_t i;
	uint16_t dACBit = 1;


	// set startingPointCHx
	if(params->channel0Enabled==true){
		ESI_setAFE1DACValue(params->channel0StartingPoint,
				CHANNEL_0_DAC1_UPPER_REGISTER);
		ESI_setAFE1DACValue(params->channel0StartingPoint,
				CHANNEL_0_DAC1_LOWER_REGISTER);
	}
	if(params->channel1Enabled==true){
		ESI_setAFE1DACValue(params->channel1StartingPoint,
				CHANNEL_1_DAC1_UPPER_REGISTER);
		ESI_setAFE1DACValue(params->channel1StartingPoint,
				CHANNEL_1_DAC1_LOWER_REGISTER);
	}
	if(params->channel2Enabled==true){
		ESI_setAFE1DACValue(params->channel2StartingPoint,
				CHANNEL_2_DAC1_UPPER_REGISTER);
		ESI_setAFE1DACValue(params->channel2StartingPoint,
				CHANNEL_2_DAC1_LOWER_REGISTER);
	}


/*******************************************************************************
 * Sets dACBit to proper range based on rangeNum
 ******************************************************************************/
	for(i=1; i<params->range; i++){
		dACBit <<= 1;
	}

/*******************************************************************************
 * Turns on ESI module and enables ESISTOP flag
 ******************************************************************************/
	ESI_clearInterrupt(ESI_INTERRUPT_FLAG_ESISTOP);
	ESI_enableInterrupt(ESI_INTERRUPT_ESISTOP);
	ESI_enable();



	 // this for loop is to find an initial DAC value for ch0 and ch1

	for(i = 0; i<params->range; i++){			// test "rangeNum" times as 12 bit DAC

		//__bis_SR_register(LPM3_bits+GIE);   	//	 wait for the ESISTOP flag


		/**
		 * Determine if ESI_CHANNEL_0 was detected as 0 or 1
		 *
		 * -If "0" increment ESIDAC1R2 and ESIDAC1R3 value
		 * -If "1" decrement ESIDAC1R2 and ESIDAC1R3 value
		 *
		 */
		if(params->channel0Enabled==true){
			if(!ESI_getLatchedComparatorOutput(CHANNEL_0_PPU_SELECT)){
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_0_DAC1_UPPER_REGISTER) + dACBit, CHANNEL_0_DAC1_UPPER_REGISTER);
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_0_DAC1_LOWER_REGISTER) + dACBit, CHANNEL_0_DAC1_LOWER_REGISTER);
			} else {
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_0_DAC1_UPPER_REGISTER) - dACBit, CHANNEL_0_DAC1_UPPER_REGISTER);
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_0_DAC1_LOWER_REGISTER) - dACBit, CHANNEL_0_DAC1_LOWER_REGISTER);
			}
		}

		/**
		 * Determine if ESI_CHANNEL_1 was detected as 0 or 1
		 *
		 * -If "0" increment ESIDAC1R4 and ESIDAC1R5 value
		 * -If "1" decrement ESIDAC1R4 and ESIDAC1R5 value
		 *
		 */
		if(params->channel1Enabled==true){
			if(!ESI_getLatchedComparatorOutput(CHANNEL_1_PPU_SELECT)){
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_1_DAC1_UPPER_REGISTER) + dACBit, CHANNEL_1_DAC1_UPPER_REGISTER);
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_1_DAC1_LOWER_REGISTER) + dACBit, CHANNEL_1_DAC1_LOWER_REGISTER);
			} else {
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_1_DAC1_UPPER_REGISTER) - dACBit, CHANNEL_1_DAC1_UPPER_REGISTER);
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_1_DAC1_LOWER_REGISTER) - dACBit, CHANNEL_1_DAC1_LOWER_REGISTER);
			}
		}
		/**
		 * Determine if ESI_CHANNEL_2 was detected as 0 or 1
		 *
		 * -If "0" increment ESIDAC1R6 and ESIDAC1R7 value
		 * -If "1" decrement ESIDAC1R6 and ESIDAC1R7 value
		 *
		 */
		if(params->channel2Enabled==true){
			if(!ESI_getLatchedComparatorOutput(CHANNEL_2_PPU_SELECT)){
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_2_DAC1_UPPER_REGISTER) + dACBit, CHANNEL_2_DAC1_UPPER_REGISTER);
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_2_DAC1_LOWER_REGISTER) + dACBit, CHANNEL_2_DAC1_LOWER_REGISTER);
			} else {
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_2_DAC1_UPPER_REGISTER) - dACBit, CHANNEL_2_DAC1_UPPER_REGISTER);
				ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_2_DAC1_LOWER_REGISTER) - dACBit, CHANNEL_2_DAC1_LOWER_REGISTER);
			}
		}

		dACBit >>= 1;

	}

	ESI_disable();
	ESI_clearInterrupt(ESI_INTERRUPT_FLAG_ESISTOP);

}



static void FindDAC_Fast_Range(fastParams *params)
{
#define CH0_INCREASING_SEARCH_DIR						BIT0
#define CH0_DECREASING_SEARCH_DIR						BIT1
#define CH1_INCREASING_SEARCH_DIR						BIT2
#define CH1_DECREASING_SEARCH_DIR						BIT3
#define CH2_INCREASING_SEARCH_DIR						BIT4
#define CH2_DECREASING_SEARCH_DIR						BIT5
#define CH0_COMPLETE									BIT8
#define CH1_COMPLETE									BIT9
#define CH2_COMPLETE									BITA
#define ENABLE_SEARCHING_LOOP							BITF

	uint16_t range= params->range;
	uint16_t rangeStatus=0;

	// Set DAC starting point
	if(params->channel0Enabled==true){
		ESI_setAFE1DACValue(params->channel0StartingPoint,CHANNEL_0_DAC1_UPPER_REGISTER);
		ESI_setAFE1DACValue(params->channel0StartingPoint,CHANNEL_0_DAC1_LOWER_REGISTER);
	}

	if(params->channel1Enabled==true){
		ESI_setAFE1DACValue(params->channel1StartingPoint,CHANNEL_1_DAC1_UPPER_REGISTER);
		ESI_setAFE1DACValue(params->channel1StartingPoint,CHANNEL_1_DAC1_LOWER_REGISTER);
	}

	if(params->channel2Enabled==true){
		ESI_setAFE1DACValue(params->channel2StartingPoint,CHANNEL_2_DAC1_UPPER_REGISTER);
		ESI_setAFE1DACValue(params->channel2StartingPoint,CHANNEL_2_DAC1_LOWER_REGISTER);
	}

	// This is the searching Loop enable bit.
	rangeStatus |= ENABLE_SEARCHING_LOOP;

	// Clear any pending ESISTOP Interrupt and enable ESI module
	ESI_clearInterrupt(ESI_INTERRUPT_FLAG_ESISTOP);
	ESI_enableInterrupt(ESI_INTERRUPT_ESISTOP);
	ESI_enable();


/******************************************************************************
 *
 * This loop is to find the starting point of DAC and the direction of searching
 * by adding or subtracting a value of "Range" into or from the DAC
 *
 ******************************************************************************/

	while (rangeStatus&ENABLE_SEARCHING_LOOP){

		while(!((rangeStatus&CH0_COMPLETE) && (rangeStatus&CH1_COMPLETE))){


			//	 wait for the ESISTOP flag
			//__bis_SR_register(LPM3_bits+GIE);

			if(params->channel0Enabled ==true){
				if(!(rangeStatus&CH0_COMPLETE)){
					// channel 0;
					if (ESI_getLatchedComparatorOutput(CHANNEL_0_PPU_SELECT)){
						// check if there is a decreasing direction mark of channel 0.
						// if yes, put a completion mark for channel 0
						// if no, put a direction mark pointing to increasing for channel 0.
						if(rangeStatus&CH0_DECREASING_SEARCH_DIR){
							rangeStatus |= CH0_COMPLETE;
						}else{
							rangeStatus |= CH0_INCREASING_SEARCH_DIR;
						}

						// decrease the CHO DAC registers by a value of "range"
						ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_0_DAC1_UPPER_REGISTER) - range,CHANNEL_0_DAC1_UPPER_REGISTER);
						ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_0_DAC1_LOWER_REGISTER) - range,CHANNEL_0_DAC1_LOWER_REGISTER);

					}else{
						// check if there is a increasing direction mark of channel 0.
						// if yes, put a completion mark for channel 0
						// if no, put a direction mark pointing to decreasing for channel 0.
						if(rangeStatus&CH1_INCREASING_SEARCH_DIR){
							rangeStatus |= CH0_COMPLETE;
						} else{
							rangeStatus |= CH0_DECREASING_SEARCH_DIR;
						}
						// increase the CHO DAC registers by a value of "range"
						ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_0_DAC1_UPPER_REGISTER) + range,CHANNEL_0_DAC1_UPPER_REGISTER);
						ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_0_DAC1_LOWER_REGISTER) + range,CHANNEL_0_DAC1_LOWER_REGISTER);
					}
				}
			}

			if(params->channel1Enabled==true){
				if(!(rangeStatus&CH1_COMPLETE)){
					// channel 1;
					if (ESI_getLatchedComparatorOutput(CHANNEL_1_PPU_SELECT)){
						// check if there is a decreasing direction mark of channel 1.
						// if yes, put a completion mark for channel 1
						// if no, put a direction mark pointing to increasing for channel 1.
						if(rangeStatus&CH1_DECREASING_SEARCH_DIR){
							rangeStatus |= CH1_COMPLETE;
						} else {
							rangeStatus |= CH1_INCREASING_SEARCH_DIR;
						}
						// decrease the CH1 DAC registers by a value of "range"
						ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_1_DAC1_UPPER_REGISTER) - range,CHANNEL_1_DAC1_UPPER_REGISTER);
						ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_1_DAC1_LOWER_REGISTER) - range,CHANNEL_1_DAC1_LOWER_REGISTER);
					} else {
						// check if there is a increasing direction mark of channel 1.
						// if yes, put a completion mark for channel 1
						// if no, put a direction mark pointing to decreasing for channel 1.
						if(rangeStatus&CH1_INCREASING_SEARCH_DIR){
							rangeStatus |= CH1_COMPLETE;
						} else{
							rangeStatus |= CH1_DECREASING_SEARCH_DIR;
						}
						// increase the CH1 DAC registers by a value of "range"
						ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_1_DAC1_UPPER_REGISTER) + range,CHANNEL_1_DAC1_UPPER_REGISTER);
						ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_1_DAC1_LOWER_REGISTER) + range,CHANNEL_1_DAC1_LOWER_REGISTER);
					}
				}
			}

			if(params->channel2Enabled ==true){
				if(!(rangeStatus&CH2_COMPLETE)){
					// channel 1;
					if (ESI_getLatchedComparatorOutput(CHANNEL_2_PPU_SELECT)){
						// check if there is a decreasing direction mark of channel 1.
						// if yes, put a completion mark for channel 1
						// if no, put a direction mark pointing to increasing for channel 1.
						if(rangeStatus&CH2_DECREASING_SEARCH_DIR){
							rangeStatus |= CH2_COMPLETE;
						} else {
							rangeStatus |= CH2_INCREASING_SEARCH_DIR;
						}
						// decrease the CH1 DAC registers by a value of "range"
						ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_2_DAC1_UPPER_REGISTER) - range,CHANNEL_2_DAC1_UPPER_REGISTER);
						ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_2_DAC1_LOWER_REGISTER) - range,CHANNEL_2_DAC1_LOWER_REGISTER);
					} else {
						// check if there is a increasing direction mark of channel 1.
						// if yes, put a completion mark for channel 1
						// if no, put a direction mark pointing to decreasing for channel 1.
						if(rangeStatus&CH2_INCREASING_SEARCH_DIR){
							rangeStatus |= CH2_COMPLETE;
						} else{
							rangeStatus |= CH2_DECREASING_SEARCH_DIR;
						}
						// increase the CH1 DAC registers by a value of "range"
						ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_2_DAC1_UPPER_REGISTER) + range,CHANNEL_2_DAC1_UPPER_REGISTER);
						ESI_setAFE1DACValue(ESI_getAFE1DACValue(CHANNEL_2_DAC1_LOWER_REGISTER) + range,CHANNEL_2_DAC1_LOWER_REGISTER);
					}
				}
			}
		}

		if (range > 1){
			// clear the flag of completion
			rangeStatus &= ~(CH0_COMPLETE + CH1_COMPLETE + CH2_COMPLETE);
			// optional, clear the direction flag
			rangeStatus &= ~(CH0_INCREASING_SEARCH_DIR +
							 CH0_DECREASING_SEARCH_DIR +
							 CH1_INCREASING_SEARCH_DIR +
							 CH1_DECREASING_SEARCH_DIR +
							 CH2_INCREASING_SEARCH_DIR +
							 CH2_DECREASING_SEARCH_DIR);
			// This is to restart the loop with searching value of one, by "+/- 1 method"
			range = 1;
		} else {
			// "+/- 1 method completed, the loop end here
			rangeStatus &= ~ENABLE_SEARCHING_LOOP;
		}

	}

	ESI_disable();
	ESI_disableInterrupt(ESI_INTERRUPT_ESISTOP);

}



















